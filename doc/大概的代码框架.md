要完成这个“行研雷达”智能体，代码框架需要围绕 **“感知（抓取）— 认知（对比）— 存储（持久化）”** 的闭环来构建。

建议采用 **面向对象** 的方式编写，方便在 Serverless 环境下调用执行。

### 1. 核心代码架构图

### 2. Python 代码框架参考

你可以基于以下结构进行开发。这里使用了逻辑分层，将抓取、处理和存储解耦：

Python

```
import time
from abc import ABC, abstractmethod

# 1. 存储层：封装 OSS/S3 操作
class StorageProvider:
    def save_report(self, version: str, content: dict):
        # 存入 OSS/S3，Key 建议包含时间戳
        pass
    
    def get_latest_report(self) -> dict:
        # 获取上一个版本的结论，用于增量对比
        pass

# 2. 抓取层：模拟全网资讯抓取
class NewsScraper:
    def fetch_by_keywords(self, keywords: list):
        # 实际开发时这里接入新闻 API 或 网页爬虫
        return [{"source": "官方", "text": "...", "priority": 10}]

# 3. 核心智能体：处理逻辑
class ResearchRadarAgent:
    def __init__(self):
        self.storage = StorageProvider()
        self.scraper = NewsScraper()
        self.priority_map = {"官方": 3, "媒体": 2, "传闻": 1}

    def run(self, keywords):
        # A. 自动巡检：获取新数据
        new_data = self.scraper.fetch_by_keywords(keywords)
        
        # B. 获取旧结论
        old_report = self.storage.get_latest_report()
        
        # C. 增量对比与冲突仲裁 (调用 LLM)
        diff_result = self._analyze_increment(old_report, new_data)
        
        # D. 更新并高亮显示
        if diff_result:
            self.storage.save_report(str(int(time.time())), diff_result)
            self._render_highlight(diff_result)

    def _analyze_increment(self, old, new_info):
        """
        这里是 Prompt Engineering 的核心。
        将 old 和 new 拼接，发给 LLM 识别数值变动。
        """
        prompt = f"旧结论：{old}\n新资讯：{new_info}\n请找出变动点并按来源优先级排序..."
        # 调用 LLM API (如 OpenAI 或 DashScope)
        return "LLM 返回的结构化 JSON"

    def _render_highlight(self, result):
        # 在终端或前端渲染高亮变动
        pass

# 4. 云函数入口
def handler(event, context):
    agent = ResearchRadarAgent()
    agent.run(["半导体行业", "AI芯片"])
    return "Scan Completed"
```

---

### 3. 关键模块实现思路

- 数据结构化 (The Schema)：
    
    不要直接对比长文本。先让 LLM 把资讯转为 Key-Value 形式（例如：{"毛利率": "20%"}），对比两个 JSON 对象的差异（Diff）要比对比纯文本准确得多。
    
- 冲突仲裁逻辑 (Arbitration)：
    
    在代码中维护一个 source_weights 字典。如果新资讯与旧结论冲突：
    
    - `if new_source_weight >= old_source_weight`: 覆盖旧结论。
        
    - `else`: 保留旧结论，但将新资讯记为“侧面参考”。
        
- 云原生定时 (Serverless)：
    
    如果你使用阿里云 FC，只需在控制台设置 Cron 表达式（例如 0 0 */6 * * * 表示每 6 小时执行一次 handler 函数）。
    

### 4. 接下来建议的操作

你可以先从 **`_analyze_increment`** 这个函数开始写起，这是最能体现“智能体”水平的地方。

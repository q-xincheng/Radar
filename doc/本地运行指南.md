# 行研雷达 - 本地运行指南

本文档说明如何在本地环境中运行和调试行研雷达系统。

## 前置要求

1. **Python 3.9+**
2. **依赖库**（需要安装）:
   - langchain-openai
   - 其他依赖见项目根目录（如有 requirements.txt）

## 一、环境变量配置

### 1.1 必需的环境变量

在运行之前，必须设置以下环境变量：

```bash
# LLM API 密钥（必填）
export SILICONFLOW_API_KEY="your-api-key-here"

# LLM 配置（可选，使用默认值）
export LLM_MODEL="deepseek-ai/DeepSeek-V3"
export LLM_BASE_URL="https://api.siliconflow.cn/v1"
export LLM_TEMPERATURE="0.1"
export LLM_MAX_RETRIES="3"

# 默认关键词（可选）
export DEFAULT_KEYWORD="半导体"

# 数据存储目录（可选）
export DATA_DIR="data"
```

### 1.2 可选的环境变量（云端存储）

如果需要使用阿里云 OSS 存储（暂未实现）：

```bash
export OSS_ACCESS_KEY_ID="your-access-key-id"
export OSS_ACCESS_KEY_SECRET="your-access-key-secret"
export OSS_ENDPOINT="oss-cn-hangzhou.aliyuncs.com"
export OSS_BUCKET="your-bucket-name"
export OSS_PREFIX="radar/"
```

### 1.3 使用 .env 文件（推荐）

创建 `.env` 文件（不要提交到 Git）：

```bash
# .env
SILICONFLOW_API_KEY=sk-xxxxxxxxxxxxxxxxxxxxxxxxx
DEFAULT_KEYWORD=半导体
DATA_DIR=data
```

然后在运行前加载：

```bash
# Linux/Mac
export $(cat .env | xargs)

# 或者使用 python-dotenv
pip install python-dotenv
```

## 二、本地运行方式

### 2.1 方式一：直接运行主流程

```bash
cd /path/to/Radar

# 进入 codes 目录
cd codes

# 运行一次完整的 pipeline
python3 -c "from orchestrator import run_pipeline; import json; result = run_pipeline('半导体'); print(json.dumps(result, ensure_ascii=False, indent=2))"
```

### 2.2 方式二：模拟 FC Handler 调用

```bash
cd /path/to/Radar

# 使用默认关键词
python3 -m codes.trigger_layer

# 使用自定义关键词
python3 -m codes.trigger_layer 新能源

# 或者
python3 codes/trigger_layer.py 新能源
```

### 2.3 方式三：使用 Python 交互式调用

```python
import os
os.chdir('/path/to/Radar/codes')

from trigger_layer import handler

# 模拟 FC 调用
event = {"keyword": "新能源"}
context = None
result = handler(event, context)

print(result)
```

### 2.4 方式四：使用 s CLI 本地调用（需要安装 Serverless Devs）

```bash
# 安装 Serverless Devs CLI
npm install -g @serverless-devs/s

# 进入项目根目录
cd /path/to/Radar

# 本地调用
s local invoke -e '{"keyword": "半导体"}'

# 带完整日志
s local invoke -e '{"keyword": "半导体"}' --debug
```

## 三、查看输出文件

执行完成后，输出文件会保存在 `data/` 目录（或你配置的 `DATA_DIR`）：

```bash
cd data/

# 查看目录结构
tree .
# 或者
ls -la

# 应该看到以下文件：
# data/
# ├── history/
# │   └── report_20260120_123456.json  # 历史归档快照
# ├── latest_fetch.json                # 最新采集的原始数据
# └── latest_report.json               # 最新分析报告
```

### 3.1 查看最新采集数据

```bash
# 查看最新采集的原始数据
cat data/latest_fetch.json | jq .

# 或者使用 Python
python3 -c "import json; print(json.dumps(json.load(open('data/latest_fetch.json')), ensure_ascii=False, indent=2))"
```

### 3.2 查看最新分析报告

```bash
# 查看最新的分析报告（包含决策和全局总结）
cat data/latest_report.json | jq .

# 只查看全局总结
cat data/latest_report.json | jq -r .global_summary
```

### 3.3 查看历史快照

```bash
# 列出所有历史快照
ls -lh data/history/

# 查看最新的历史快照
latest_snapshot=$(ls -t data/history/report_*.json | head -1)
cat "$latest_snapshot" | jq .
```

## 四、常见问题排查

### 4.1 LLM API 密钥错误

**错误信息**: `ValueError: LLM API key not found`

**解决方法**:
```bash
# 确认环境变量已设置
echo $SILICONFLOW_API_KEY

# 如果为空，重新设置
export SILICONFLOW_API_KEY="your-api-key-here"
```

### 4.2 数据目录不存在

**错误信息**: `FileNotFoundError: [Errno 2] No such file or directory: 'data'`

**解决方法**:
```bash
# 创建数据目录
mkdir -p data/history
```

### 4.3 采集失败或无新数据

**日志信息**: `WARNING - 采集失败或无新数据，跳过本次处理`

**说明**: 这是正常的保护机制。当采集层返回空数据时，系统会跳过处理，不会覆盖旧数据。

**检查方法**:
```bash
# 检查采集层是否正常工作
python3 -c "from codes.scraper_layer import ScraperAgent; agent = ScraperAgent(); items = agent.fetch('半导体'); print(f'采集到 {len(items)} 条数据')"
```

### 4.4 权限问题

**错误信息**: `PermissionError: [Errno 13] Permission denied`

**解决方法**:
```bash
# 确保数据目录有写权限
chmod -R u+w data/
```

## 五、完整示例：从零开始运行

```bash
# 1. 克隆仓库
git clone https://github.com/q-xincheng/Radar.git
cd Radar

# 2. 安装依赖（如果有 requirements.txt）
pip3 install -r requirements.txt

# 3. 设置环境变量
export SILICONFLOW_API_KEY="sk-your-api-key-here"
export DEFAULT_KEYWORD="半导体"

# 4. 创建数据目录
mkdir -p data/history

# 5. 运行一次测试
python3 codes/trigger_layer.py

# 6. 查看结果
cat data/latest_report.json | python3 -m json.tool

# 7. 查看日志（如果运行时输出到文件）
tail -f radar.log  # 如果有日志文件
```

## 六、数据文件说明

### 6.1 latest_fetch.json - 最新采集数据

这个文件保存了最新一次采集的原始数据，包含：
- `keyword`: 采集关键词
- `collected_at`: 采集时间戳
- `items`: 采集到的资讯列表
  - `title`: 标题
  - `content`: 内容
  - `source`: 来源类型（official/media/rumor）
  - `url`: 链接
  - `published_at`: 发布时间

**用途**: 作为增量对比的 `new_items` 输入

### 6.2 latest_report.json - 最新分析报告

这个文件保存了最新一次分析的结论，包含：
- `keyword`: 关键词
- `generated_at`: 生成时间戳
- `global_summary`: 全局总结
- `decisions`: 各指标的决策列表
  - `field`: 指标名称
  - `final_value`: 最终采纳值
  - `chosen_source`: 选择的来源
  - `pending_sources`: 待核实的其他来源
  - `reason`: 决策理由（AI 洞察）

**用途**: 作为下次增量对比的 `old_snapshot` 输入

### 6.3 history/ - 历史归档

这个目录保存了所有历史快照，文件名格式：`report_YYYYMMDD_HHMMSS.json`

**用途**: 
- 历史回溯
- 趋势分析
- 数据恢复

## 七、进阶：调试和开发

### 7.1 调试单个模块

```python
# 测试存储层
from codes.storage_layer import StorageClient
storage = StorageClient()

# 测试加载
latest_fetch = storage.load_latest_fetch()
current_report = storage.load_current_report()
print(f"最新采集: {latest_fetch}")
print(f"当前报告: {current_report}")
```

```python
# 测试增量分析
from codes.incremental_analysis import incremental_compare
from codes.storage_layer import StorageClient

storage = StorageClient()
old_snapshot = storage.load_current_report()
latest_fetch = storage.load_latest_fetch()

if latest_fetch:
    changes = incremental_compare(old_snapshot, latest_fetch.items)
    print(f"发现 {len(changes)} 项变化:")
    for c in changes:
        print(f"  - {c.field}: {c.old} -> {c.new} ({c.status})")
```

### 7.2 启用详细日志

```python
import logging
logging.basicConfig(
    level=logging.DEBUG,  # 改为 DEBUG 级别
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
```

### 7.3 性能分析

```bash
# 使用 time 命令
time python3 codes/trigger_layer.py

# 使用 Python profiler
python3 -m cProfile -s cumulative codes/trigger_layer.py
```

## 八、故障处理流程

1. **检查环境变量**: 确保 `SILICONFLOW_API_KEY` 已设置
2. **检查网络**: 确保能访问 LLM API 端点
3. **检查文件权限**: 确保数据目录可写
4. **查看日志**: 检查详细的错误信息
5. **重试机制**: 系统内置了重试逻辑，会自动重试 2 次
6. **手动恢复**: 如果数据损坏，可以从 `history/` 目录恢复

## 九、生产部署建议

1. **环境变量管理**: 使用密钥管理服务（如阿里云 KMS）
2. **日志收集**: 配置日志服务（如阿里云 SLS）
3. **监控告警**: 设置执行失败告警
4. **定期备份**: 定期备份 `history/` 目录
5. **权限最小化**: 只给必要的 OSS/FC 权限

---

如有问题，请参考项目文档或提交 Issue。
